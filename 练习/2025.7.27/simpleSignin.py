from Crypto.Util.number import inverse, long_to_bytes

# —— 1. 导入题目给定的 n, c —— 
n = 91717197306065801430692774296739087369692505805873730729014813677164858033475119219496549179322145782790263228034134781592967028480301579462111507372893508636592832600206391905790511488678949157112322777098684707325311891056750963286494634489093620270797637437274546909400418496263799669541769586017282231886023275686719495040493703402244867906367008837217453500300992995258096509545406775279177918160331853363991834113918051468978309081085686108283547874975768959542753094631595260890420558364636303078263220001513817844063960023424429484568985727987064710176511050208253838039386390968276801658300795687804601169987051671314061987254212363117325786734328360418591971610392966867659045907550755979167652038093091970078722854251659581538266806207906127491377972897441916942048136016416739633568604447564119372465662628724153812001753748410162478969725179843125714619352895967577899670208386148053595763674920185320834513587

c = 42839011426405997183903064099635369826330453992570625970187419298692038242873340653343908015720875659378036817158685551628122217251118628262238465344190964816124580515458311589588181306296351778223861262126155125515973896503862879452134790831154504719292417905542768994118748777728649139178447183393367548054248947947431492235965656603368249032481251726201814793707367255423795360154002568107516580925236531750315901863488819318860921565896077238102673526816090928925925751075205315025490968147316509309315086832359525106203975670062755669310591511541201410020995195041443209092074953245174428606205236898973322350365005188942046012164423380551528973172062821695472964847483144558009935347106019767003947501794910291787761506146324383099394195404192915582482886260648618931172730212751598584218599542997084683196266265460113955019678010205955389076617695217597085275764572543474258054602748997334079905377228138451474442238

e = 0x10001

# —— 2. 枚举第10~19位，共 2^10 种可能 —— 
R = PolynomialRing(ZZ, 'x')
x = R.gen()

for guess in range(1<<10):
    # 拼出已知部分 p0
    p0 = (gift2 << 20) + (guess << 10) + gift1
    f  = x + p0
    # 在 n 意义下找出 |x| < 2^205 的小根
    roots = f.small_roots(X=2**205, beta=0.5)
    if not roots:
        continue

    x0 = roots[0]
    p  = int(p0 + x0)      # 恢复出 p
    if n % p != 0:
        continue

    print("[+] 找到 p：", p)
    # —— 3. 分解出 q, r —— 
    tmp = n // p
    # 由于 r = next_prime(q), q,r 差距很小，可以直接遍历或用 next_prime 反推
    from Crypto.Util.number import next_prime
    # 简单做个循环找 q
    for delta in range(0, 2000):
        q = tmp // next_prime(tmp//(delta+1))
        if q * next_prime(q) == tmp:
            r = next_prime(q)
            break

    # —— 4. 计算私钥并解密 —— 
    phi = (p-1)*(q-1)*(r-1)
    d   = inverse(e, phi)
    m   = pow(c, d, n)
    flag = long_to_bytes(int(m))
    print("[+] 解出 flag：", flag)
    break