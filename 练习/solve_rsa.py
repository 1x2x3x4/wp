import gmpy2
from Crypto.Util.number import long_to_bytes

# 从题目输出复制过来
n = 81554001352662655582031105852601096112813583207628624684299968786780092085554342029239967832885217664462643187340191068464818247315640986611176642105385047154662914081984498070907218761404235566427207873573330088182582027405515379867176562518529412992340647935963612987152552411234446887942945019858049330649
c = 9909291647970882773070955029552047328472555998723065817096333147080771476308744711432564535410835860260582380105711102870660576108398044248029519465372900661561620103803700798761449279943456533424577732054015408039715488483810769020259241938304714881012435253010255850953432867939718077178059659164088356934
e = 0x10001  # 公钥指数

# 1. 计算整数平方根
A = gmpy2.isqrt(n)

# 2. 由 q≈p+2^200 可知 sqrt(n)≈p+2^199
#    因此 p_approx = A - 2^199
p_approx = int(A - (1 << 199))

# 3. 在一个小区间内线性搜索真正的 p
p = None
for k in range(-2000, 2000):
    candidate = p_approx + k
    if candidate > 0 and n % candidate == 0:
        p = candidate
        break

if p is None:
    raise ValueError("未能在搜索范围内找到 p，请适当扩大范围")

q = n // p

# 4. 计算 φ(n) 和私钥 d
phi = (p - 1) * (q - 1)
d   = int(gmpy2.invert(e, phi))

# 5. 解密并输出 flag
m    = pow(c, d, n)
flag = long_to_bytes(m)
print(flag)
